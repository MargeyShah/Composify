from pathlib import Path
from typing import Any, Dict, List, Optional
from composify import Service
from ruamel.yaml import YAML
from ruamel.yaml.comments import CommentedMap, CommentedSeq
from ruamel.yaml.parser import ParserError
import ipaddress
import subprocess
import shlex

# Shared YAML instance (round-trip capable for comment handling)
yaml_rt = YAML()
yaml_rt.preserve_quotes = True
yaml_rt.indent(mapping=2, sequence=2, offset=2)

# ---------------------------
# File I/O helpers
# ---------------------------

def list_yaml_files(root: Path) -> List[Path]:
    return sorted(p for p in root.rglob("*.yml") if p.is_file())


def _fix_ipam_gateway_indentation_text(yaml_text: str) -> str:
    """
    If a 'gateway:' line under networks.*.ipam.config list is wrongly aligned at the
    same indent as the sequence dash, indent it two more spaces so it belongs to
    the mapping of that list item. This is a conservative text fix.
    """
    lines = yaml_text.splitlines(keepends=True)

    def leading_spaces(s: str) -> int:
        i = 0
        while i < len(s) and s[i] == ' ':
            i += 1
        return i

    for i in range(1, len(lines)):
        line = lines[i]
        stripped = line.lstrip()
        if not stripped.startswith("gateway:"):
            continue

        # Find previous non-empty/non-comment line
        j = i - 1
        while j >= 0 and (lines[j].strip() == "" or lines[j].lstrip().startswith("#")):
            j -= 1
        if j < 0:
            continue

        prev = lines[j]
        prev_stripped = prev.lstrip()
        # Only fix when previous line is a list item like "- subnet: ..."
        if not prev_stripped.startswith("- "):
            continue

        indent_gw = leading_spaces(line)
        indent_dash = leading_spaces(prev)
        # If gateway is at the same indent as the dash (or less), push it under the item mapping
        if indent_gw <= indent_dash:
            lines[i] = (" " * (indent_dash + 2)) + stripped

    return "".join(lines)


def _postfix_main_compose_file(path: Path) -> None:
    """
    After writing MAIN_COMPOSE, fix any ipam.gateway indentation drift if present.
    """
    if not path.exists():
        return
    text = path.read_text(encoding="utf-8")
    fixed = _fix_ipam_gateway_indentation_text(text)
    if fixed != text:
        path.write_text(fixed, encoding="utf-8")


def load_main_compose(main_compose: Path) -> CommentedMap:
    """
    Load the root compose with resilience against known ipam.gateway indentation drift.
    """
    if not main_compose.exists():
        return CommentedMap()

    text = main_compose.read_text(encoding="utf-8")
    if not text.strip():
        return CommentedMap()

    try:
        data = yaml_rt.load(text) or CommentedMap()
    except ParserError:
        # Try to sanitize mis-indented ipam.gateway and reload
        fixed = _fix_ipam_gateway_indentation_text(text)
        if fixed != text:
            data = yaml_rt.load(fixed) or CommentedMap()
            # Persist the sanitized version
            with main_compose.open("w", encoding="utf-8") as f:
                f.write(fixed)
        else:
            raise

    if not isinstance(data, CommentedMap):
        data = CommentedMap()
    return data


def get_existing_service_names(compose_path: Path) -> List[str]:
    """Return the list of service names in an existing compose file; raise if services: missing."""
    if not compose_path.exists():
        raise SystemExit(f"Compose file not found: {compose_path}")
    data = yaml_rt.load(compose_path.read_text(encoding="utf-8")) or CommentedMap()
    if not isinstance(data, (dict, CommentedMap)):
        data = CommentedMap()
    services = data.get("services")
    if not isinstance(services, (dict, CommentedMap)):
        raise SystemExit(f"{compose_path} has no top-level 'services:'")
    return [str(k) for k in services.keys()]


def _normalize_comment_text(s: Optional[str]) -> Optional[str]:
    """
    Normalize comment text for ruamel.yaml:
    - Strip whitespace
    - Remove leading '#' (ruamel adds '# ' automatically)
    """
    if s is None:
        return None
    s = s.strip()
    if not s:
        return None
    if s.startswith("#"):
        s = s.lstrip("#").strip()
    return s or None


def upsert_service_in_file(compose_path: Path, svc: Service) -> None:
    """
    Load compose_path, ensure top-level services: exists, and insert/update the given service.
    No overwrite question is asked; caller must ensure name is unique beforehand.
    Adds two comment lines above the service:
      # <service name>
      # generated by composify
    """
    if not compose_path.exists():
        raise SystemExit(f"Compose file not found: {compose_path}")

    data = yaml_rt.load(compose_path.read_text(encoding="utf-8")) or CommentedMap()
    if not isinstance(data, CommentedMap):
        data = CommentedMap()

    services = data.get("services")
    if services is None or not isinstance(services, (dict, CommentedMap)):
        raise SystemExit(f"{compose_path} has no top-level 'services:'")

    # Insert/update the service
    services[svc.name] = svc.to_compose_value()

    # Add header comments before the service key (indented correctly)
    try:
        services.yaml_set_comment_before_after_key(
            svc.name,
            before=[_normalize_comment_text(svc.name), "generated by composify"],
            indent=2,
        )
    except Exception:
        pass

    with compose_path.open("w", encoding="utf-8") as f:
        yaml_rt.dump(data, f)


def write_new_stack_file(stack_compose: Path, svc: Service, overwrite: bool) -> None:
    """
    Create a new compose file with a single service, adding two header comments above it.
    """
    stack_compose.parent.mkdir(parents=True, exist_ok=True)
    if stack_compose.exists() and not overwrite:
        raise SystemExit(f"{stack_compose} already exists. Use overwrite to replace it.")

    data = CommentedMap()
    services = CommentedMap()
    services[svc.name] = svc.to_compose_value()
    data["services"] = services

    # Add header comments before the service key
    try:
        services.yaml_set_comment_before_after_key(
            svc.name,
            before=[_normalize_comment_text(svc.name), "generated by composify"],
            indent=2,
        )
    except Exception:
        pass

    with stack_compose.open("w", encoding="utf-8") as f:
        yaml_rt.dump(data, f)


def append_to_include_with_comment(main_compose: Path, rel_include_path: str, comment_text: str) -> bool:
    """
    Append an include path with a comment above it, keeping indentation aligned.
    """
    data = load_main_compose(main_compose)

    include = data.get("include")
    if include is None:
        include = CommentedSeq()
        data["include"] = include
    if not isinstance(include, CommentedSeq):
        raise SystemExit(f"Top-level 'include' is not a list in {main_compose}")

    existing = [str(item) for item in include]
    if rel_include_path in existing:
        return False

    include.append(rel_include_path)
    idx = len(include) - 1
    try:
        before = _normalize_comment_text(comment_text)
        if before:
            # indent=2 so the comment aligns with the sequence indentation
            include.yaml_set_comment_before_after_key(idx, before=before, indent=2)
    except Exception:
        pass

    with main_compose.open("w", encoding="utf-8") as f:
        yaml_rt.dump(data, f)
    _postfix_main_compose_file(main_compose)
    return True


# ---------------------------
# Middleware chain discovery
# ---------------------------

def list_middleware_chains(file: Path) -> List[str]:
    """
    Parse a traefik middleware chains file and return the chain names under:
      http.middlewares.<chain-name>
    """
    if not file.exists():
        return []
    data = yaml_rt.load(file.read_text(encoding="utf-8")) or {}
    try:
        http = data.get("http") or {}
        mws = http.get("middlewares") or {}
        names = [str(k) for k in mws.keys()]
        names.sort()
        return names
    except Exception:
        return []


# ---------------------------
# Pretty-print helpers
# ---------------------------

def dump_yaml_str(obj: Any) -> str:
    from io import StringIO
    buf = StringIO()
    yaml_rt.dump(obj, buf)
    return buf.getvalue()


def dump_include_only_str(data: CommentedMap) -> str:
    out = CommentedMap()
    if "include" in data:
        out["include"] = data["include"]
    return dump_yaml_str(out)


def simulate_include_after_append_str(main_compose: Path, rel_include_path: str, comment_text: str) -> str:
    data = load_main_compose(main_compose)

    include = data.get("include")
    if include is None:
        include = CommentedSeq()
        data["include"] = include
    if not isinstance(include, CommentedSeq):
        raise SystemExit(f"Top-level 'include' is not a list in {main_compose}")

    existing = [str(item) for item in include]
    if rel_include_path not in existing:
        include.append(rel_include_path)
        idx = len(include) - 1
        try:
            before = _normalize_comment_text(comment_text)
            if before:
                include.yaml_set_comment_before_after_key(idx, before=before, indent=2)
        except Exception:
            pass

    return dump_include_only_str(data)


# ---------------------------
# Networks helpers (NEW)
# ---------------------------

def derive_app_name_from_compose(compose_path: Path, stacks_root: Path) -> str:
    """
    If compose is directly under stacks_root (e.g., stacks/foo.yml) => 'foo' (stem).
    Else use first folder under stacks_root (e.g., stacks/app1/docker-compose.yml => 'app1').
    """
    rel = compose_path.relative_to(stacks_root)
    parts = list(rel.parts)
    if len(parts) == 1:
        return compose_path.stem
    return parts[0]


def list_root_network_subnets(main_compose: Path) -> List[str]:
    """
    Return a list of subnet strings from top-level networks.ipam.config[].subnet in the root compose.
    """
    data = load_main_compose(main_compose)
    nets = data.get("networks")
    if not isinstance(nets, (dict, CommentedMap)):
        return []
    found: List[str] = []
    for v in nets.values():
        if not isinstance(v, (dict, CommentedMap)):
            continue
        ipam = v.get("ipam")
        if not isinstance(ipam, (dict, CommentedMap)):
            continue
        cfg = ipam.get("config")
        if isinstance(cfg, (list, CommentedSeq)):
            for ent in cfg:
                if isinstance(ent, (dict, CommentedMap)) and "subnet" in ent:
                    s = str(ent["subnet"])
                    if s:
                        found.append(s)
    return found


def pick_unused_subnet(existing_subnets: List[str]) -> str:
    """
    Pick an unused /24 that doesn't overlap 'existing_subnets'.
    Preference: 172.20.0.0/24 .. 172.200.0.0/24, else 10.x.0.0/24.
    """
    used = []
    for s in existing_subnets:
        try:
            used.append(ipaddress.ip_network(s, strict=False))
        except Exception:
            pass

    def free(cand: ipaddress.IPv4Network) -> bool:
        return all(not cand.overlaps(u) for u in used)

    for second in list(range(20, 100)) + list(range(100, 201)):
        cand = ipaddress.ip_network(f"172.{second}.0.0/24", strict=False)
        if free(cand):
            return str(cand)
    for second in range(10, 255):
        cand = ipaddress.ip_network(f"10.{second}.0.0/24", strict=False)
        if free(cand):
            return str(cand)
    raise SystemExit("Unable to find a free /24 subnet")


def upsert_network_in_main_compose(main_compose: Path, net_name: str, subnet: str, internal: bool = True) -> None:
    """
    Ensure a network exists in the root compose with the given name and subnet.
    If it already exists with a different subnet, raise.
    """
    data = load_main_compose(main_compose)
    nets = data.get("networks")
    if nets is None:
        nets = CommentedMap()
        data["networks"] = nets
    if not isinstance(nets, (dict, CommentedMap)):
        raise SystemExit(f"Top-level 'networks' is not a mapping in {main_compose}")

    existing = nets.get(net_name)
    if isinstance(existing, (dict, CommentedMap)):
        ipam = existing.get("ipam") or {}
        cfg = (ipam.get("config") or [])
        existing_subnet = None
        if isinstance(cfg, (list, CommentedSeq)) and cfg:
            first = cfg[0]
            if isinstance(first, (dict, CommentedMap)):
                existing_subnet = first.get("subnet")
        if existing_subnet and str(existing_subnet) != str(subnet):
            raise SystemExit(
                f"Network '{net_name}' already exists with subnet {existing_subnet} (wanted {subnet})."
            )
        # already present and OK
    else:
        net_map = CommentedMap()
        net_map["name"] = net_name
        net_map["internal"] = bool(internal)

        ipam_map = CommentedMap()
        cfg_seq = CommentedSeq()
        cfg_entry = CommentedMap()
        cfg_entry["subnet"] = subnet
        cfg_seq.append(cfg_entry)
        ipam_map["config"] = cfg_seq
        net_map["ipam"] = ipam_map

        nets[net_name] = net_map

    with main_compose.open("w", encoding="utf-8") as f:
        yaml_rt.dump(data, f)
    _postfix_main_compose_file(main_compose)


def attach_network_to_services(compose_path: Path, service_names: List[str], net_name: str) -> None:
    """
    Add 'net_name' to each service's networks list/dict if not already present.
    """
    if not service_names:
        return
    if not compose_path.exists():
        raise SystemExit(f"Compose file not found: {compose_path}")

    data = yaml_rt.load(compose_path.read_text(encoding="utf-8")) or CommentedMap()
    if not isinstance(data, CommentedMap):
        data = CommentedMap()
    services = data.get("services")
    if not isinstance(services, (dict, CommentedMap)):
        raise SystemExit(f"{compose_path} has no top-level 'services:'")

    changed = False
    for name in service_names:
        svc = services.get(name)
        if not isinstance(svc, (dict, CommentedMap)):
            continue
        nets = svc.get("networks")
        if nets is None:
            svc["networks"] = CommentedSeq([net_name])
            changed = True
        elif isinstance(nets, (list, CommentedSeq)):
            if net_name not in [str(x) for x in nets]:
                nets.append(net_name)
                changed = True
        elif isinstance(nets, (dict, CommentedMap)):
            if net_name not in nets:
                nets[net_name] = None
                changed = True
        else:
            svc["networks"] = CommentedSeq([net_name])
            changed = True

    if changed:
        with compose_path.open("w", encoding="utf-8") as f:
            yaml_rt.dump(data, f)


# ---------------------------
# Secrets helpers (NEW)
# ---------------------------

def upsert_root_secrets(main_compose: Path, app_display_name: str, secret_names: List[str]) -> None:
    """
    Ensure top-level secrets: mapping exists and contains the given secret_names.
    Values point to $SECRETSDIR/<secret_name>. Insert alphabetically, and add a
    single comment '# <App Display Name> Secrets' before the first inserted secret.
    Raise if any secret already exists (to avoid accidental reuse/conflict).
    """
    data = load_main_compose(main_compose)
    secrets_map = data.get("secrets")
    if secrets_map is None:
        secrets_map = CommentedMap()
        data["secrets"] = secrets_map
    if not isinstance(secrets_map, (dict, CommentedMap)):
        raise SystemExit(f"Top-level 'secrets' is not a mapping in {main_compose}")

    # Check for existing
    for name in secret_names:
        if name in secrets_map:
            raise SystemExit(f"Secret '{name}' already exists in {main_compose}")

    # Insert alphabetically
    current_keys = [str(k) for k in secrets_map.keys()]
    for i, name in enumerate(sorted(secret_names)):
        val = CommentedMap({"file": f"$SECRETSDIR/{name}"})
        # find insertion index among current keys (which grows as we insert)
        insert_at: Optional[int] = None
        for idx, k in enumerate(current_keys):
            if name < k:
                insert_at = idx
                break
        if insert_at is None:
            secrets_map[name] = val
            current_keys.append(name)
        else:
            try:
                secrets_map.insert(insert_at, name, val)  # ruamel's CommentedMap.insert(index, key, value)
            except TypeError:
                # Older ruamel versions use (key, value, index)
                secrets_map.insert(name, val, insert_at)
            current_keys.insert(insert_at, name)

        # Add comment only once, before the first of our keys (indented to key level)
        if i == 0:
            try:
                before = _normalize_comment_text(f"{app_display_name} Secrets")
                if before:
                    secrets_map.yaml_set_comment_before_after_key(name, before=before, indent=2)
            except Exception:
                pass

    with main_compose.open("w", encoding="utf-8") as f:
        yaml_rt.dump(data, f)
    _postfix_main_compose_file(main_compose)


def ensure_secret_files(secret_dir: Path, contents: Dict[str, str]) -> None:
    """
    Create files under secret_dir as root using sudo, with 0600 perms.
    Does not overwrite; if any file exists, raise.
    """
    # Ensure directory exists
    subprocess.run(["sudo", "mkdir", "-p", str(secret_dir)], check=True)

    # Pre-check existence as root
    for name in contents.keys():
        target = secret_dir / name
        rc = subprocess.run(["sudo", "test", "-e", str(target)]).returncode
        if rc == 0:
            raise SystemExit(f"Secret file already exists: {target}")

    # Create files with restrictive perms (umask 177 => 600)
    for name, value in contents.items():
        target = secret_dir / name
        cmd = f"umask 177; cat > {shlex.quote(str(target))}"
        subprocess.run(["sudo", "bash", "-c", cmd], input=(value.rstrip() + "\n").encode("utf-8"), check=True)

